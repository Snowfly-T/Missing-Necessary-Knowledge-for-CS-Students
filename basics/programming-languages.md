# 编程语言

## 编译器与解释器

世界上主要存在两种类型的编程语言——一种依靠**解释器**直接运行，被称为**解释型语言**，另一种先将代码**编译**到目标平台的二进制码，然后运行这些二进制代码，被称为**编译型语言**。

前者很简洁，免去了编译的困扰，打开就开始一行一行地运行代码，并且具有更好的自由度，可以在运行代码时更灵活地做出改变。比如 Python 就属于这种类型的编程语言。

而后者虽然多了编译这一步骤，但编译后的代码执行速度很快。只要源代码不更改，一次编译便可以永远享受编译后代码的高速。并且，由于编译器是整个读入代码，再输出为二进制码，相比于一行行运行程序地解释器，知道程序的整体结构是什么样子，因此也能对程序进行性能方面的优化。当然，相比于前者，由于引入了编译与优化的步骤，程序的灵活性必然会受到一定的影响，这也是编译型语言为了性能所必须做出的一些取舍。比如 C/C++就属于这种类型的编程语言。

然而，事实上情况并非总是这么简单。例如 Java 实际上是先将源代码（.java 文件）编译为 Java 字节码（.class）文件，然后通过一个被称为”Java 虚拟机“的环境解释运行字节码的。这样做能使 Java 代码在各种不同的平台上运行而无需考虑兼容性问题——只需要对应平台安装了对应平台版本的 Java 虚拟机。因此，人们说 Java 是一门”跨平台“的编程语言。而相比于努力让编译后的代码直接在各种平台上运行，只保证 Java 虚拟机在各种平台上能够正常运行则要简单的多，并且不容易发生意外。

此外，通过使用虚拟机运行代码，还能较为轻松地实现”垃圾回收“功能，即能够让程序自动以尽可能高效地方式管理内存的分配与回收，而无需程序员手动释放内存——例如 C/C++就是需要程序员手动释放内存、不包含垃圾回收器的语言，这为编码造成了许多麻烦。

这样使用虚拟机的语言还有很多，并且占据主流。Python、Ruby、JavaScript、Java、C#等都是具有虚拟机与垃圾回收器的编程语言。

可以看到，其实 Python 也不完全是一门解释型语言——Python 事实上在运行一段程序之前也会将其编译为 Python 字节码（bytecode），然后通过解释器逐行运行字节码。只是这个过程要简单得多，不像 Java/C++等编程语言会在编译期间做大量的检查及优化工作，因此一般仍旧认为 Python 是一门解释型语言。并且通常来说，我们也将 Java 这样的编程语言认为是一门编译型语言。

不过，虚拟机当然是存在代价的，而这一代价就是性能。通过虚拟机运行程序，毕竟不是直接通过原生代码运行程序，性能上必然会有损失。Java 虚拟机通过数十年的努力在通常情况下达到了接近 C++编译成的原生代码的性能，但在许多情况下，很多场景仍旧因为需要极高的性能而只能选择 C++而不是 Java。并且，Java 虚拟机高性能的一个代价就是需要占用大量的内存，这也体现在另一个同样规模庞大的前端 JavaScript 引擎 V8 上——你或许可以感受到，Chrome 浏览器在标签页开多了之后会有比较明显的卡顿，这和 V8 引擎较大的内存占用不无关系。

## 强类型与弱类型

![各编程语言的类型系统](img/pl-types.png)

强类型、弱类型、静态类型与动态类型是四个经常被混淆的术语。在本小节，先阐释一下强类型与弱类型的区别。

强类型与弱类型语言最重要区别就在于是否大量采用隐式转换。弱类型语言通常会做大量的隐式转换，而强类型语言不会。例如，考虑下面这段伪代码：

```
a = 5
b = "4"
sum = a - b
```

在弱类型语言中，常常直接将这里的`b`先从字符串`"4"`转换为数字`4`，然后进行运算，得到`sum`为 1。而在强类型语言中，规定`-`运算符两边只能是数字，因此发现`b`是字符串就会报错，而不会尝试计算出结果。

很多人说 Python 是”弱类型语言“，这其实是将”弱类型“与下面即将阐明的”动态类型“相混淆了。上面这样的代码在 Python 中仍会报错，Python 不会”自作聪明“地像很多弱类型语言一样做隐式转换，所以 Python 显然是强类型的。

甚至在 Java 这样的静态强类型语言中，`"abc" + 42`这样的代码会做特殊处理。即，如果字符串与任意其他类型的值相加，会先尝试将另一个值转换为字符串，然后进行字符串拼接。而在 Python 中，这也是不允许的，你必须写成`"abc" + str(42)`才行，这更说明了 Python 的强类型本质。

## 静态类型与动态类型

”静态类型“与”动态类型“，则是对一门编程语言是否在编译期就能确定变量类型的区分。例如，考虑下面这段伪代码：

```
a = 1
a = true
```

在 Python 这样的动态类型语言中，不规定变量类型必须不变，因此类似这样的代码是正确的。而在 Java、C#、TypeScript 等编程语言中，这样的代码是不能通过编译的。这就是对静态类型语言和动态类型语言的简单区分。

可以注意到，即使在上面区分动态类型与静态类型的例子中，我也没有写下面这种代码：

```c
int a = 1;
a = TRUE;
```

这是一段 C 语言代码，并且它是正确且能够通过编译的。很多人认为一门语言在变量定义时需要声明类型（比如这里的`int`）就认为它是”强类型“的，这实际上属于完全的误解——甚至 C 语言还是静态弱类型的。判断一个变量是什么类型的，实际上根本不需要依赖于程序员显式声明类型：

```
a = 1
b = true
c = []
```

在上面这段代码中，程序员并没有为这三个变量声明类型，但编译期仍旧能够很容易地得知 a 是数字、b 是布尔量、而 c 是一个列表/数组。这种无需显式声明类型也能推导出变量类型的能力被称为”类型推断“。因此，在很多现代的静态类型编程语言中，都是可以在许多情况中使用编程语言的类型推断能力，而无需操心为变量给出一个具体的声明的：

```c++
auto h{new Holder{42}}; // Holder<int> *
auto num{42} // int
auto nums{new int[10]}; // int *
auto nums2{std::array<int, 5>{1, 2, 3, 4, 5}}; // std::array<int, 5>
std::array<int, 5> nums3{1, 2, 3, 4, 5}; // std::array<int, 5>
```

静态类型语言一个很大的优势在于，能够通过类型系统在编译阶段检查出程序中一些潜在的 BUG，例如考虑下面这段 Python 代码：

```python
def get_text_length(s):
    return len(s)

get_text_length(42)
```

这段代码只有在实际运行到了`get_text_length(42)`这一句时才会报错。而在一些较大的项目中，有些代码可能本就很难被运行到，若类似这样的代码潜藏在程序中，就会产生许多难以发现的 BUG。而在一些静态类型语言，比如 TypeScript 中，这样的问题将在编译时被检查出来：

```typescript
function getTextLength(s: string) {
  return len(s);
}

getTextLength(42);
```

在编译时，`getTextLength(42)`会直接报错，因为 TypeScript 知道`getTextLength`函数只能用于字符串。类似这样的被称作”静态类型检查“的工作提升了代码的可靠性。

再考虑下面这段 Python 代码，思考静态类型带来的另一个优势：

```python
def process_string(s):
    s.split(...)
    ...

process_string(...)
```

在你编写`process_string`函数时，你会发现当你输入了`s.`之后，编辑器并没有像你期望地给出提示，告诉你变量`s`上可以调用哪些方法，比如`split`、`join`、`isnumeric`等——因为 Python 不知道变量`s`是什么类型的，不知道它是字符串、数字、布尔量或是其他什么，因此自然不会给你这些提示。

而在 TypeScript 中，你标注了`s`的类型之后，编辑器就能根据类型给出相应的提示：

```typescript
function processString(s: string) {
  s.split(...)
  ...
}

processString(...)
```

在这里，当你输入了`s.`之后，编辑器知道变量`s`是一个字符串，因此就会给出相应的提示。

这就是静态类型的另一大优势：可以在编写代码时给出更多的提示。并且，结合之前提到的”类型推断“，实际上在很多现代的静态类型语言中，你都不怎么需要手动标注变量的类型——最常见的只是你需要标注函数中参数的类型而已。因此，对于很多程序员来说，静态类型语言反而意味着只要付出极少的代价（添上一点点类型标注）就可以获得极高的编程效率提升（得益于编辑器提供的智能提示和静态类型检查）。

而在过去，在编辑器和编译器还没有今天这么智能的时代，静态类型语言既没有类型推断，而编辑器也没有智能提示，人们普遍认为静态类型语言的开发效率要比动态类型语言更低。然而在今天，事情已经完全不一样了。

不过，动态类型语言也并非完全无法享受类型推断与智能提示带来的好处。例如 Python 自 3.5 后提供了被称作”类型提示（type hints）“的语法，你也可以通过在变量后面加个冒号，标上可选的类型，提示编辑器该变量的类型，以获得智能提示，就像 TypeScript 一样。很多动态类型编程语言都采用了这种方式，这被称为”渐进式类型“，即并不强制标上类型，而是在你认为需要的地方标上类型。只不过，相比大多数静态类型语言，大多数动态类型语言中的”渐进式类型“不够完备，缺少足够强大的类型推断能力。

## 面向对象与函数式编程

有两种基本的“**编程范式（Programming Paradigms）**”：“**命令式编程（Imperative Programming）**”与“**声明式编程（Declarative Programming）**”.

然而实际中，我们常常讨论的是“**面向对象编程（Object-Oriented Programming）**”与“**函数式编程（Functional Programming）**”，它们分别代表了命令式编程与声明式编程。实际上，命令式编程除了面向对象编程，还包含传统的过程式编程，如 C 语言的通常编程方式；而声明式编程，也包含了逻辑式编程、数学编程及响应式编程等方式。

在这里，简单展示一下面向对象编程与函数式编程的差异。为了易于理解，这里都使用了 Java：

```java
public class Words {
    private Set<String> NON_WORDS = new HashSet<>() {{
        add("the"); add("and"); add("of"); add("to"); add("a");
        add("i"); add("it"); add("in"); add("or"); add("is");
        add("d"); add("s"); add("as"); add("so"); add("but");
        add("be");
    }};

    public Map<String, Integer> wordFreq(String words) {
        TreeMap<String, Integer> wordMap = new TreeMap<>();
        Matcher m = Pattern.compile("\\w+").matcher(words);
        while (m.find()) {
            String word = m.group().toLowerCase();
            if (!NON_WORDS.contains(word)) {
                if (wordMap.containsKey(word)) {
                    wordMap.put(word, wordMap.get(word) + 1);
                } else {
                    wordMap.put(word, 1);
                }
            }
        }
        return wordMap;
    }
 }
```

```java
private List<String> regexToList(String words, String regex) {
    List<String> wordList = new ArrayList<>();
    Matcher m = Pattern.compile(regex).matcher(words);
    while (m.find()) {
        wordList.add(m.group());
    }
    return wordList;
}

public Map<String, Integer> wordFreq(String words) {
    TreeMap<String, Integer> wordMap = new TreeMap<>();
    regexToList(words, "\\w+").stream()
            .map(String::toLowerCase)
            .filter(word -> !NON_WORDS.contains(word))
            .forEach(word -> wordMap.put(
                    word,
                    wordMap.getOrDefault(word, 0) + 1
            ));
    return wordMap;
}
```

可以看到，后者相比于前者的嵌套层级更少。并且它们具有本质上的区别：前者描述了程序工作的具体细节，描述“该怎么做”，而后者描述了程序应该输出什么，通过一个个变换描述“想要得到什么”。

实际上，真正函数式风格的代码要比这里的 Java 代码简洁得多。比如这是一段用 Clojure 编写的，处理一个员工姓名列表的代码：

```clojure
(defn process [list-of-emps]
  (->> list-of-emps
    (filter #(< 1 (count %)))
    (map s/capitalize)
    (interpose ", ")
    (reduce str)))
```

通常认为函数式编程提供了一种比面向对象编程更高阶的抽象方式。在面向对象编程中，我们传递对象，使用对象上的方法来完成某一功能；而在函数式编程中，我们通过组合一系列函数实现某一功能。实际上，这两种方式应该并无明确的好坏之分，而仅仅代表了两种思维方式的差异。

目前普遍的观点认为，对于业务中数据的处理，使用偏函数式编程的模式能够更清晰地表达逻辑。而对于大型程序各部分之间的组织，使用面向对象的思路会更加合适。

不过，许多观点也认为，使用函数式编程同样能够清晰地组织大规模的程序，例如使用“**领域驱动设计（Design Driven Design, DDD）**”，这是一种通用的设计程序的形式，而不仅仅限于某种具体的编程范式，只是人们已经习惯于使用面向对象的思想来组织程序了。

不过，关键是要清楚这两种编程范式并非对立的，而是可以结合使用的。在程序中恰当地使用函数式编程思想，往往能使我们的代码变得更加清晰且易于维护。
